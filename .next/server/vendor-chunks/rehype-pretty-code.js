"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rehype-pretty-code";
exports.ids = ["vendor-chunks/rehype-pretty-code"];
exports.modules = {

/***/ "(rsc)/./node_modules/rehype-pretty-code/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/rehype-pretty-code/dist/index.js ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   rehypePrettyCode: () => (/* binding */ rehypePrettyCode)\n/* harmony export */ });\n/* harmony import */ var shiki__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiki */ \"shiki\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-string */ \"(rsc)/./node_modules/hast-util-to-string/lib/index.js\");\n/* harmony import */ var parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse-numeric-range */ \"(rsc)/./node_modules/parse-numeric-range/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unified */ \"(rsc)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rehype-parse */ \"(rsc)/./node_modules/rehype-parse/lib/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([shiki__WEBPACK_IMPORTED_MODULE_0__]);\nshiki__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n// src/index.ts\nfunction isJSONTheme(value) {\n  return value ? Object.hasOwn(value, \"tokenColors\") : false;\n}\nfunction isElement(value) {\n  return value ? value.type === \"element\" : false;\n}\nfunction isText(value) {\n  return value ? value.type === \"text\" : false;\n}\nfunction isInlineCode(element, parent) {\n  return element.tagName === \"code\" && isElement(parent) && parent.tagName !== \"pre\" || element.tagName === \"inlineCode\";\n}\nfunction isBlockCode(element) {\n  return element.tagName === \"pre\" && Array.isArray(element.children) && element.children.length === 1 && isElement(element.children[0]) && element.children[0].tagName === \"code\";\n}\nfunction getInlineCodeLang(meta, defaultFallbackLang) {\n  const placeholder = \"\\0\";\n  let temp = meta.replace(/\\\\\\\\/g, placeholder);\n  temp = temp.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\");\n  const lang = temp.match(/{:([a-zA-Z.-]+)}$/)?.[1];\n  return lang?.replace(new RegExp(placeholder, \"g\"), \"\\\\\") || defaultFallbackLang;\n}\nfunction parseBlockMetaString(element, filter, defaultFallback) {\n  let meta = filter(\n    // @ts-expect-error: TODO handle this\n    element.data?.meta ?? element.properties?.metastring ?? \"\"\n  );\n  const titleMatch = meta.match(/title=\"([^\"]*)\"/);\n  const title = titleMatch?.[1] ?? null;\n  meta = meta.replace(titleMatch?.[0] ?? \"\", \"\");\n  const captionMatch = meta.match(/caption=\"([^\"]*)\"/);\n  const caption = captionMatch?.[1] ?? null;\n  meta = meta.replace(captionMatch?.[0] ?? \"\", \"\");\n  let lang = defaultFallback;\n  if (element.properties && Array.isArray(element.properties.className) && typeof element.properties.className[0] === \"string\" && element.properties.className[0].startsWith(\"language-\")) {\n    lang = element.properties.className[0].replace(\"language-\", \"\");\n  }\n  return {\n    title,\n    caption,\n    lang,\n    meta\n  };\n}\nfunction getThemeNames(theme) {\n  if (isJSONTheme(theme)) {\n    return [theme.name];\n  }\n  if (typeof theme === \"string\") {\n    return [theme];\n  }\n  return Object.values(theme).map(\n    (theme2) => typeof theme2 === \"string\" ? theme2 : theme2.name\n  );\n}\nfunction replaceLineClass(element) {\n  if (Array.isArray(element.properties?.className) && element.properties.className.includes(\"line\")) {\n    const className = element.properties.className.filter((c) => c !== \"line\");\n    element.properties.className = className.length > 0 ? className : void 0;\n    element.properties[\"data-line\"] = \"\";\n  }\n}\nfunction getLineId(lineNumber, meta) {\n  const segments = meta.match(/\\{[^}]+\\}#[a-zA-Z0-9]+/g);\n  if (!segments)\n    return null;\n  for (const segment of segments) {\n    const [range, id] = segment.split(\"#\");\n    if (!(range && id))\n      continue;\n    const match = range.match(/\\{(.*?)\\}/);\n    const capture = match?.[1];\n    if (capture && parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(capture).includes(lineNumber)) {\n      return id;\n    }\n  }\n  return null;\n}\n\n// src/chars/splitElement.ts\nfunction splitElement({\n  elements,\n  elementToWrap,\n  innerString,\n  rightString,\n  leftString,\n  rest,\n  nextElementContinues,\n  index,\n  ignoreChars\n}) {\n  if (isElement(elementToWrap) && elementToWrap.children?.[0]?.type !== \"text\" || ignoreChars) {\n    return [elementToWrap, index];\n  }\n  let newIndex = index;\n  const textElement = elementToWrap.children[0];\n  if (isText(textElement)) {\n    textElement.value = innerString;\n  }\n  let rightStr = rightString;\n  const leftStr = leftString;\n  if (rest.length > 0) {\n    rightStr += rest.map((s) => s === \"\" ? innerString : innerString + s).join(\"\");\n  }\n  if (leftStr.length > 0) {\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: leftStr }]\n    });\n  }\n  if (rightStr.length > 0 && !nextElementContinues) {\n    newIndex = leftStr.length > 0 ? newIndex + 2 : newIndex + 1;\n    elements.splice(newIndex, 0, {\n      ...elementToWrap,\n      properties: { ...elementToWrap.properties },\n      children: [{ type: \"text\", value: rightStr }]\n    });\n  }\n  return [elementToWrap, index + 1];\n}\nfunction nextElementMaybeContinuesChars({\n  elements,\n  nextIndex,\n  remainingPart\n}) {\n  if (remainingPart === \"\") {\n    return false;\n  }\n  const nextNode = elements[nextIndex];\n  const content = getContent(nextNode);\n  if (!content) {\n    return false;\n  }\n  const includesNext = content.startsWith(remainingPart) || remainingPart.startsWith(content);\n  const overlap = findOverlap(content, remainingPart);\n  if (overlap === remainingPart && content.startsWith(remainingPart)) {\n    return true;\n  }\n  if (includesNext) {\n    return nextElementMaybeContinuesChars({\n      elements,\n      nextIndex: nextIndex + 1,\n      remainingPart: remainingPart.replace(content, \"\")\n    });\n  }\n  return false;\n}\nfunction getContent(node) {\n  if (!node)\n    return;\n  return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(node);\n}\nfunction findOverlap(a, b) {\n  if (b.length === 0) {\n    return \"\";\n  }\n  if (a.endsWith(b)) {\n    return b;\n  }\n  if (a.indexOf(b) >= 0) {\n    return b;\n  }\n  return findOverlap(a, b.substring(0, b.length - 1));\n}\nfunction reverseString(s) {\n  return s.split(\"\").reverse().join(\"\");\n}\n\n// src/chars/getElementsToHighlight.ts\nfunction getElementsToHighlight(element, chars, startIndex = 0, ignoreChars = false) {\n  const toWrap = [];\n  let charsSoFar = \"\";\n  if (element.children) {\n    const elements = element.children;\n    for (let i = startIndex; i < elements.length; i++) {\n      const remaining = charsSoFar ? chars.replace(charsSoFar, \"\") : chars;\n      if (remaining === \"\") {\n        return toWrap;\n      }\n      const maybeElement = elements[i];\n      if (!maybeElement || maybeElement.type !== \"element\" || // ignore any previously matched chars within\n      Object.hasOwn(\n        maybeElement.properties ?? {},\n        \"rehype-pretty-code-visited\"\n      )) {\n        continue;\n      }\n      const content = getContent(maybeElement) || \"\";\n      if (content === chars || charsSoFar + content === chars) {\n        toWrap.push({ element: maybeElement, index: i });\n        return toWrap;\n      }\n      if (chars.startsWith(charsSoFar + content)) {\n        if (nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: remaining.replace(content, \"\")\n        })) {\n          toWrap.push({ element: elements[i], index: i });\n          charsSoFar += content;\n          continue;\n        }\n      }\n      const overlap = findOverlap(content, remaining);\n      const partialMatch = overlap && remaining.startsWith(overlap);\n      if (partialMatch) {\n        const nextPart = remaining.replace(overlap, \"\");\n        if (nextPart !== \"\" && getContent(elements[i + 1]) && !nextElementMaybeContinuesChars({\n          elements,\n          nextIndex: i + 1,\n          remainingPart: nextPart\n        })) {\n          continue;\n        }\n        const splitParts = content.split(overlap);\n        const [leftPart, rightPart, ...rest] = splitParts;\n        if (rightPart || leftPart || rest.length > 0) {\n          const withNextNode = content + (getContent(elements[i + 1]) ? getContent(elements[i + 1]) : \"\");\n          const nextNodeOverlap = findOverlap(withNextNode, remaining);\n          const splitIndex = withNextNode.indexOf(nextNodeOverlap);\n          if (chars.endsWith(overlap) || chars.startsWith(overlap)) {\n            const rightString = rightPart.replace(overlap, \"\");\n            const innerString = overlap;\n            const leftString = content.substring(0, splitIndex);\n            const nextElementContinues = nextElementMaybeContinuesChars({\n              elements,\n              nextIndex: i + 1,\n              remainingPart: nextPart\n            });\n            const [newElement, updatedIndex] = splitElement({\n              elements,\n              elementToWrap: elements[i],\n              innerString,\n              rightString,\n              leftString,\n              rest,\n              nextElementContinues,\n              index: i,\n              ignoreChars\n            });\n            charsSoFar += overlap;\n            toWrap.push({\n              element: newElement,\n              index: updatedIndex\n            });\n          }\n        }\n      }\n    }\n  }\n  return toWrap;\n}\n\n// src/chars/wrapHighlightedChars.ts\nfunction wrapHighlightedChars(parentElement, elementsToWrap, options, ignoreWord, onVisitHighlightedChars) {\n  if (!elementsToWrap || elementsToWrap.length === 0) {\n    return;\n  }\n  const [{ element }] = elementsToWrap;\n  if (ignoreWord) {\n    if (element.properties) {\n      element.properties[\"rehype-pretty-code-visited\"] = \"\";\n    }\n    return;\n  }\n  if (elementsToWrap.length > 1) {\n    parentElement.children.splice(\n      elementsToWrap[0].index,\n      elementsToWrap.length,\n      {\n        type: \"element\",\n        tagName: \"mark\",\n        properties: { \"data-highlighted-chars-mark\": \"\" },\n        children: elementsToWrap.map(({ element: element3 }) => element3)\n      }\n    );\n    const element2 = parentElement.children[elementsToWrap[0].index];\n    if (!isElement(element2)) {\n      return;\n    }\n    const wordStr = element2.children.reduce((acc, node) => {\n      const textElement = isElement(node) ? node.children[0] : null;\n      if (isText(textElement)) {\n        return acc + textElement.value;\n      }\n      return acc;\n    }, \"\");\n    const id = options.idsMap.get(wordStr);\n    element2.properties = element2.properties || {};\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    onVisitHighlightedChars?.(element2, id);\n  } else {\n    const [{ element: element2 }] = elementsToWrap;\n    const textElement = element2.children[0];\n    if (!isText(textElement)) {\n      return;\n    }\n    const id = options.idsMap.get(textElement.value);\n    element2.properties = element2.properties || {};\n    element2.properties[\"rehype-pretty-code-visited\"] = \"\";\n    element2.properties[\"data-highlighted-chars\"] = \"\";\n    element2.properties[\"data-chars-id\"] = id;\n    element2.tagName = \"mark\";\n    element2.children = [\n      {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          style: element2.properties.style\n        },\n        children: element2.children\n      }\n    ];\n    element2.properties.style = void 0;\n    onVisitHighlightedChars?.(element2, id);\n  }\n}\nfunction charsHighlighter(element, charsList, options, onVisitHighlightedChars) {\n  const { ranges = [] } = options;\n  const textContent = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n  charsList.forEach((chars, index) => {\n    if (chars && textContent?.includes(chars)) {\n      let textContent2 = (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element);\n      let startIndex = 0;\n      while (textContent2.includes(chars)) {\n        const currentCharsRange = ranges[index] || [];\n        const id = `${chars}-${index}`;\n        options.counterMap.set(id, (options.counterMap.get(id) || 0) + 1);\n        const ignoreChars = currentCharsRange.length > 0 && !currentCharsRange.includes(options.counterMap.get(id) ?? -1);\n        const elementsToWrap = getElementsToHighlight(\n          element,\n          chars,\n          startIndex,\n          ignoreChars\n        );\n        if (elementsToWrap.length === 0)\n          break;\n        wrapHighlightedChars(\n          element,\n          elementsToWrap,\n          options,\n          ignoreChars,\n          onVisitHighlightedChars\n        );\n        startIndex = Math.max(\n          elementsToWrap[elementsToWrap.length - 1].index - 2,\n          0\n        );\n        textContent2 = element.children.map((childNode) => {\n          const props = isElement(childNode) ? childNode.properties : {};\n          if (props && !Object.hasOwn(props, \"rehype-pretty-code-visited\") && !Object.hasOwn(props, \"data-highlighted-chars-mark\")) {\n            return (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(childNode);\n          }\n        }).join(\"\");\n      }\n    }\n  });\n  element.children.forEach((childNode) => {\n    if (!isElement(childNode))\n      return;\n    if (Object.hasOwn(childNode.properties, \"rehype-pretty-code-visited\")) {\n      childNode.properties[\"rehype-pretty-code-visited\"] = void 0;\n    }\n  });\n}\n\n// src/index.ts\nfunction apply(element, {\n  tree,\n  lang,\n  title,\n  caption,\n  inline = false,\n  keepBackground = true,\n  grid = true,\n  lineNumbersMaxDigits = 1,\n  theme,\n  onVisitTitle,\n  onVisitCaption\n}) {\n  element.tagName = inline ? \"span\" : \"figure\";\n  element.properties[\"data-rehype-pretty-code-figure\"] = \"\";\n  const codeData = element.children[0]?.data;\n  element.children = [tree].map((tree2) => {\n    const pre = tree2.children[0];\n    const themeNames = getThemeNames(theme);\n    const themeNamesString = themeNames.join(\" \");\n    if (!(isElement(pre) && pre.properties)) {\n      return [];\n    }\n    const code = pre.children[0];\n    if (Array.isArray(pre.properties.className) && pre.properties.className.includes(\"shiki\")) {\n      const className = pre.properties.className.filter(\n        (c) => c !== \"shiki\" && c !== \"shiki-themes\" && (typeof c === \"string\" ? !themeNames.includes(c) : true)\n      );\n      pre.properties.className = className.length > 0 ? className : void 0;\n    }\n    if (!keepBackground) {\n      pre.properties.style = void 0;\n    }\n    pre.properties[\"data-language\"] = lang;\n    pre.properties[\"data-theme\"] = themeNamesString;\n    if (!(isElement(code) && code.properties)) {\n      return [];\n    }\n    code.properties[\"data-language\"] = lang;\n    code.properties[\"data-theme\"] = themeNamesString;\n    code.data = codeData;\n    if (inline) {\n      if (keepBackground) {\n        code.properties.style = pre.properties.style;\n      }\n      return code;\n    }\n    if (grid) {\n      if (code.properties.style) {\n        code.properties.style += \"display: grid;\";\n      } else {\n        code.properties.style = \"display: grid;\";\n      }\n    }\n    if (Object.hasOwn(code.properties, \"data-line-numbers\")) {\n      code.properties[\"data-line-numbers-max-digits\"] = lineNumbersMaxDigits.toString().length;\n    }\n    const fragments = [];\n    if (title) {\n      const elementContent = {\n        type: \"element\",\n        tagName: caption ? \"div\" : \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-title\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: title }]\n      };\n      onVisitTitle?.(elementContent);\n      fragments.push(elementContent);\n    }\n    fragments.push(pre);\n    if (caption) {\n      const elementContent = {\n        type: \"element\",\n        tagName: \"figcaption\",\n        properties: {\n          \"data-rehype-pretty-code-caption\": \"\",\n          \"data-language\": lang,\n          \"data-theme\": themeNamesString\n        },\n        children: [{ type: \"text\", value: caption }]\n      };\n      onVisitCaption?.(elementContent);\n      fragments.push(elementContent);\n    }\n    return fragments;\n  }).flatMap((c) => c);\n}\nvar globalHighlighterCache = /* @__PURE__ */ new Map();\nvar hastParser = (0,unified__WEBPACK_IMPORTED_MODULE_3__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { fragment: true });\nvar src_default = rehypePrettyCode;\nfunction rehypePrettyCode(options = {}) {\n  const {\n    grid = true,\n    theme = \"github-dark-dimmed\",\n    keepBackground = true,\n    defaultLang = \"\",\n    tokensMap = {},\n    filterMetaString = (v) => v,\n    getHighlighter: getHighlighter$1 = shiki__WEBPACK_IMPORTED_MODULE_0__.getHighlighter,\n    transformers,\n    onVisitLine,\n    onVisitHighlightedLine,\n    onVisitHighlightedChars,\n    onVisitTitle,\n    onVisitCaption\n  } = options;\n  const key = JSON.stringify(theme);\n  let cachedHighlighter = globalHighlighterCache.get(key);\n  if (!cachedHighlighter) {\n    cachedHighlighter = getHighlighter$1({\n      themes: isJSONTheme(theme) || typeof theme === \"string\" ? [theme] : Object.values(theme),\n      langs: [\"plaintext\"]\n    });\n    globalHighlighterCache.set(key, cachedHighlighter);\n  }\n  const defaultCodeBlockLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.block || \"\";\n  const defaultInlineCodeLang = typeof defaultLang === \"string\" ? defaultLang : defaultLang.inline || \"\";\n  function getOptions(lang, meta) {\n    const multipleThemes = !isJSONTheme(theme) && typeof theme === \"object\" ? theme : null;\n    const singleTheme = isJSONTheme(theme) || typeof theme === \"string\" ? theme : null;\n    return {\n      lang,\n      meta: { __raw: meta },\n      transformers,\n      defaultColor: typeof theme === \"string\" ? theme : false,\n      ...multipleThemes ? { themes: multipleThemes } : { theme: singleTheme }\n    };\n  }\n  return async (tree) => {\n    const langsToLoad = /* @__PURE__ */ new Set();\n    const highlighter = await cachedHighlighter;\n    if (!highlighter)\n      return;\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent)) {\n        const textElement = element.children[0];\n        if (!isText(textElement))\n          return;\n        const value = textElement.value;\n        if (!value)\n          return;\n        const lang = getInlineCodeLang(value, defaultInlineCodeLang);\n        if (lang && lang[0] !== \".\") {\n          langsToLoad.add(lang);\n        }\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement))\n          return;\n        const { lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (lang) {\n          langsToLoad.add(lang);\n        }\n      }\n    });\n    try {\n      await Promise.allSettled(\n        Array.from(langsToLoad).map((lang) => {\n          try {\n            return highlighter.loadLanguage(\n              lang\n            );\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        })\n      );\n    } catch (e) {\n      console.error(e);\n    }\n    (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(tree, \"element\", (element, _, parent) => {\n      if (isInlineCode(element, parent)) {\n        const textElement = element.children[0];\n        if (!isText(textElement))\n          return;\n        const value = textElement.value;\n        if (!value)\n          return;\n        const keepLangPart = /\\\\{:[a-zA-Z.-]+}$/.test(value);\n        const strippedValue = keepLangPart ? value.replace(/\\\\({:[a-zA-Z.-]+})$/, \"$1\") : value.replace(/{:[a-zA-Z.-]+}$/, \"\");\n        textElement.value = strippedValue;\n        const lang = keepLangPart ? \"\" : getInlineCodeLang(value, defaultInlineCodeLang);\n        const isLang = lang[0] !== \".\";\n        if (!lang)\n          return;\n        let codeTree;\n        if (isLang) {\n          try {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(lang))\n            );\n          } catch {\n            codeTree = hastParser.parse(\n              highlighter.codeToHtml(strippedValue, getOptions(\"plaintext\"))\n            );\n          }\n        } else {\n          const themeNames = getThemeNames(theme);\n          const isMultiTheme = typeof theme === \"object\" && !isJSONTheme(theme);\n          const themeKeys = isMultiTheme ? Object.keys(theme) : null;\n          const colorsByTheme = themeNames.map(\n            (name) => name ? highlighter.getTheme(name).settings.find(\n              ({ scope }) => scope?.includes(tokensMap[lang.slice(1)] ?? lang.slice(1))\n            )?.settings.foreground ?? \"inherit\" : \"inherit\"\n          );\n          if (isMultiTheme && themeKeys) {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"${themeKeys.map((key2, i) => `--shiki-${key2}:${colorsByTheme[i]}`).join(\";\")}\">${strippedValue}</span></code></pre>`\n            );\n          } else {\n            codeTree = hastParser.parse(\n              `<pre><code><span style=\"color:${colorsByTheme[0]}\">${strippedValue}</span></code></pre>`\n            );\n          }\n        }\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", replaceLineClass);\n        apply(element, {\n          tree: codeTree,\n          lang: isLang ? lang : \".token\",\n          inline: true,\n          keepBackground,\n          theme\n        });\n      }\n      if (isBlockCode(element)) {\n        const codeElement = element.children[0];\n        if (!isElement(codeElement))\n          return;\n        const textElement = codeElement.children[0];\n        const { title, caption, meta, lang } = parseBlockMetaString(\n          codeElement,\n          filterMetaString,\n          defaultCodeBlockLang\n        );\n        if (!lang || lang === \"math\")\n          return;\n        const lineNumbers = [];\n        if (meta) {\n          const matches = meta.matchAll(/\\B\\{(.*?)\\}\\B/g);\n          for (const match of matches) {\n            if (match[1]) {\n              lineNumbers.push(...parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(match[1]));\n            }\n          }\n        }\n        let lineNumbersMaxDigits = 0;\n        const lineIdMap = /* @__PURE__ */ new Map();\n        const charsList = [];\n        const charsListNumbers = [];\n        const charsListIdMap = /* @__PURE__ */ new Map();\n        const charsMatches = meta ? [\n          ...meta.matchAll(\n            /(?<delimiter>[\"/])(?<chars>.*?)\\k<delimiter>(?<charsIdAndOrRange>\\S*)/g\n          )\n        ] : void 0;\n        lineNumbers.forEach((lineNumber) => {\n          const id = getLineId(lineNumber, meta);\n          id && lineIdMap.set(lineNumber, id);\n        });\n        if (Array.isArray(charsMatches)) {\n          charsMatches.forEach((name) => {\n            const { chars, charsIdAndOrRange } = name.groups;\n            charsList.push(chars);\n            if (charsIdAndOrRange === \"\") {\n              charsListNumbers.push([]);\n            } else {\n              const [range, id] = charsIdAndOrRange.split(\"#\");\n              range && charsListNumbers.push(parse_numeric_range__WEBPACK_IMPORTED_MODULE_1__(range));\n              id && charsListIdMap.set(chars, id);\n            }\n          });\n        }\n        if (!isText(textElement))\n          return;\n        const strippedValue = textElement.value.replace(/\\n$/, \"\");\n        let codeTree;\n        try {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(strippedValue, getOptions(lang, meta))\n          );\n        } catch {\n          codeTree = hastParser.parse(\n            highlighter.codeToHtml(\n              strippedValue,\n              getOptions(\"plaintext\", meta)\n            )\n          );\n        }\n        let lineCounter = 0;\n        const charsHighlighterOptions = {\n          ranges: charsListNumbers,\n          idsMap: charsListIdMap,\n          counterMap: /* @__PURE__ */ new Map()\n        };\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(codeTree, \"element\", (element2) => {\n          if (element2.tagName === \"code\" && /srebmuNeniLwohs(?!(.*)(\\/))/.test(reverseString(meta))) {\n            if (element2.properties) {\n              element2.properties[\"data-line-numbers\"] = \"\";\n            }\n            const lineNumbersStartAtMatch = reverseString(meta).match(\n              /(?:\\}(\\d+){)?srebmuNeniLwohs(?!(.*)(\\/))/\n            );\n            const startNumberString = lineNumbersStartAtMatch?.[1];\n            if (startNumberString) {\n              const startAt = startNumberString ? Number(reverseString(startNumberString)) - 1 : 0;\n              lineNumbersMaxDigits = startAt;\n              if (element2.properties) {\n                element2.properties.style = `counter-set: line ${startAt};`;\n              }\n            }\n          }\n          if (Array.isArray(element2.properties?.className) && element2.properties?.className?.[0] === \"line\") {\n            if (grid && (0,hast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(element2) === \"\") {\n              element2.children = [{ type: \"text\", value: \" \" }];\n            }\n            replaceLineClass(element2);\n            onVisitLine?.(element2);\n            lineCounter++;\n            if (lineNumbers.includes(lineCounter)) {\n              element2.properties[\"data-highlighted-line\"] = \"\";\n              const lineId = lineIdMap.get(lineCounter);\n              if (lineId) {\n                element2.properties[\"data-highlighted-line-id\"] = lineId;\n              }\n              onVisitHighlightedLine?.(element2, lineId);\n            }\n            charsHighlighter(\n              element2,\n              charsList,\n              charsHighlighterOptions,\n              onVisitHighlightedChars\n            );\n            lineNumbersMaxDigits++;\n          }\n        });\n        apply(element, {\n          tree: codeTree,\n          lang,\n          title,\n          caption,\n          keepBackground,\n          grid,\n          lineNumbersMaxDigits,\n          theme,\n          onVisitTitle,\n          onVisitCaption\n        });\n      }\n    });\n  };\n}\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDRTtBQUNNO0FBQ0E7QUFDYjtBQUNLOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUcsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBLG1CQUFtQixnREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiw4QkFBOEI7QUFDakQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pELG1CQUFtQiwrQkFBK0I7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0Esd0JBQXdCLDZEQUFRO0FBQ2hDLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9yZm9saW8vLi9ub2RlX21vZHVsZXMvcmVoeXBlLXByZXR0eS1jb2RlL2Rpc3QvaW5kZXguanM/OTQ3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRIaWdobGlnaHRlciB9IGZyb20gJ3NoaWtpJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAndW5pc3QtdXRpbC12aXNpdCc7XG5pbXBvcnQgeyB0b1N0cmluZyB9IGZyb20gJ2hhc3QtdXRpbC10by1zdHJpbmcnO1xuaW1wb3J0IHJhbmdlUGFyc2VyMiBmcm9tICdwYXJzZS1udW1lcmljLXJhbmdlJztcbmltcG9ydCB7IHVuaWZpZWQgfSBmcm9tICd1bmlmaWVkJztcbmltcG9ydCByZWh5cGVQYXJzZSBmcm9tICdyZWh5cGUtcGFyc2UnO1xuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGlzSlNPTlRoZW1lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IE9iamVjdC5oYXNPd24odmFsdWUsIFwidG9rZW5Db2xvcnNcIikgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPyB2YWx1ZS50eXBlID09PSBcImVsZW1lbnRcIiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNUZXh0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHZhbHVlLnR5cGUgPT09IFwidGV4dFwiIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lubGluZUNvZGUoZWxlbWVudCwgcGFyZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwiY29kZVwiICYmIGlzRWxlbWVudChwYXJlbnQpICYmIHBhcmVudC50YWdOYW1lICE9PSBcInByZVwiIHx8IGVsZW1lbnQudGFnTmFtZSA9PT0gXCJpbmxpbmVDb2RlXCI7XG59XG5mdW5jdGlvbiBpc0Jsb2NrQ29kZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT09IFwicHJlXCIgJiYgQXJyYXkuaXNBcnJheShlbGVtZW50LmNoaWxkcmVuKSAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBpc0VsZW1lbnQoZWxlbWVudC5jaGlsZHJlblswXSkgJiYgZWxlbWVudC5jaGlsZHJlblswXS50YWdOYW1lID09PSBcImNvZGVcIjtcbn1cbmZ1bmN0aW9uIGdldElubGluZUNvZGVMYW5nKG1ldGEsIGRlZmF1bHRGYWxsYmFja0xhbmcpIHtcbiAgY29uc3QgcGxhY2Vob2xkZXIgPSBcIlxcMFwiO1xuICBsZXQgdGVtcCA9IG1ldGEucmVwbGFjZSgvXFxcXFxcXFwvZywgcGxhY2Vob2xkZXIpO1xuICB0ZW1wID0gdGVtcC5yZXBsYWNlKC9cXFxcKHs6W2EtekEtWi4tXSt9KSQvLCBcIiQxXCIpO1xuICBjb25zdCBsYW5nID0gdGVtcC5tYXRjaCgvezooW2EtekEtWi4tXSspfSQvKT8uWzFdO1xuICByZXR1cm4gbGFuZz8ucmVwbGFjZShuZXcgUmVnRXhwKHBsYWNlaG9sZGVyLCBcImdcIiksIFwiXFxcXFwiKSB8fCBkZWZhdWx0RmFsbGJhY2tMYW5nO1xufVxuZnVuY3Rpb24gcGFyc2VCbG9ja01ldGFTdHJpbmcoZWxlbWVudCwgZmlsdGVyLCBkZWZhdWx0RmFsbGJhY2spIHtcbiAgbGV0IG1ldGEgPSBmaWx0ZXIoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogVE9ETyBoYW5kbGUgdGhpc1xuICAgIGVsZW1lbnQuZGF0YT8ubWV0YSA/PyBlbGVtZW50LnByb3BlcnRpZXM/Lm1ldGFzdHJpbmcgPz8gXCJcIlxuICApO1xuICBjb25zdCB0aXRsZU1hdGNoID0gbWV0YS5tYXRjaCgvdGl0bGU9XCIoW15cIl0qKVwiLyk7XG4gIGNvbnN0IHRpdGxlID0gdGl0bGVNYXRjaD8uWzFdID8/IG51bGw7XG4gIG1ldGEgPSBtZXRhLnJlcGxhY2UodGl0bGVNYXRjaD8uWzBdID8/IFwiXCIsIFwiXCIpO1xuICBjb25zdCBjYXB0aW9uTWF0Y2ggPSBtZXRhLm1hdGNoKC9jYXB0aW9uPVwiKFteXCJdKilcIi8pO1xuICBjb25zdCBjYXB0aW9uID0gY2FwdGlvbk1hdGNoPy5bMV0gPz8gbnVsbDtcbiAgbWV0YSA9IG1ldGEucmVwbGFjZShjYXB0aW9uTWF0Y2g/LlswXSA/PyBcIlwiLCBcIlwiKTtcbiAgbGV0IGxhbmcgPSBkZWZhdWx0RmFsbGJhY2s7XG4gIGlmIChlbGVtZW50LnByb3BlcnRpZXMgJiYgQXJyYXkuaXNBcnJheShlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lKSAmJiB0eXBlb2YgZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZVswXSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lWzBdLnN0YXJ0c1dpdGgoXCJsYW5ndWFnZS1cIikpIHtcbiAgICBsYW5nID0gZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZVswXS5yZXBsYWNlKFwibGFuZ3VhZ2UtXCIsIFwiXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGl0bGUsXG4gICAgY2FwdGlvbixcbiAgICBsYW5nLFxuICAgIG1ldGFcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRoZW1lTmFtZXModGhlbWUpIHtcbiAgaWYgKGlzSlNPTlRoZW1lKHRoZW1lKSkge1xuICAgIHJldHVybiBbdGhlbWUubmFtZV07XG4gIH1cbiAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbdGhlbWVdO1xuICB9XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHRoZW1lKS5tYXAoXG4gICAgKHRoZW1lMikgPT4gdHlwZW9mIHRoZW1lMiA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lMiA6IHRoZW1lMi5uYW1lXG4gICk7XG59XG5mdW5jdGlvbiByZXBsYWNlTGluZUNsYXNzKGVsZW1lbnQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudC5wcm9wZXJ0aWVzPy5jbGFzc05hbWUpICYmIGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWUuaW5jbHVkZXMoXCJsaW5lXCIpKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5maWx0ZXIoKGMpID0+IGMgIT09IFwibGluZVwiKTtcbiAgICBlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lLmxlbmd0aCA+IDAgPyBjbGFzc05hbWUgOiB2b2lkIDA7XG4gICAgZWxlbWVudC5wcm9wZXJ0aWVzW1wiZGF0YS1saW5lXCJdID0gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGluZUlkKGxpbmVOdW1iZXIsIG1ldGEpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBtZXRhLm1hdGNoKC9cXHtbXn1dK1xcfSNbYS16QS1aMC05XSsvZyk7XG4gIGlmICghc2VnbWVudHMpXG4gICAgcmV0dXJuIG51bGw7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IFtyYW5nZSwgaWRdID0gc2VnbWVudC5zcGxpdChcIiNcIik7XG4gICAgaWYgKCEocmFuZ2UgJiYgaWQpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgbWF0Y2ggPSByYW5nZS5tYXRjaCgvXFx7KC4qPylcXH0vKTtcbiAgICBjb25zdCBjYXB0dXJlID0gbWF0Y2g/LlsxXTtcbiAgICBpZiAoY2FwdHVyZSAmJiByYW5nZVBhcnNlcjIoY2FwdHVyZSkuaW5jbHVkZXMobGluZU51bWJlcikpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy9jaGFycy9zcGxpdEVsZW1lbnQudHNcbmZ1bmN0aW9uIHNwbGl0RWxlbWVudCh7XG4gIGVsZW1lbnRzLFxuICBlbGVtZW50VG9XcmFwLFxuICBpbm5lclN0cmluZyxcbiAgcmlnaHRTdHJpbmcsXG4gIGxlZnRTdHJpbmcsXG4gIHJlc3QsXG4gIG5leHRFbGVtZW50Q29udGludWVzLFxuICBpbmRleCxcbiAgaWdub3JlQ2hhcnNcbn0pIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50VG9XcmFwKSAmJiBlbGVtZW50VG9XcmFwLmNoaWxkcmVuPy5bMF0/LnR5cGUgIT09IFwidGV4dFwiIHx8IGlnbm9yZUNoYXJzKSB7XG4gICAgcmV0dXJuIFtlbGVtZW50VG9XcmFwLCBpbmRleF07XG4gIH1cbiAgbGV0IG5ld0luZGV4ID0gaW5kZXg7XG4gIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudFRvV3JhcC5jaGlsZHJlblswXTtcbiAgaWYgKGlzVGV4dCh0ZXh0RWxlbWVudCkpIHtcbiAgICB0ZXh0RWxlbWVudC52YWx1ZSA9IGlubmVyU3RyaW5nO1xuICB9XG4gIGxldCByaWdodFN0ciA9IHJpZ2h0U3RyaW5nO1xuICBjb25zdCBsZWZ0U3RyID0gbGVmdFN0cmluZztcbiAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgIHJpZ2h0U3RyICs9IHJlc3QubWFwKChzKSA9PiBzID09PSBcIlwiID8gaW5uZXJTdHJpbmcgOiBpbm5lclN0cmluZyArIHMpLmpvaW4oXCJcIik7XG4gIH1cbiAgaWYgKGxlZnRTdHIubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnRzLnNwbGljZShuZXdJbmRleCwgMCwge1xuICAgICAgLi4uZWxlbWVudFRvV3JhcCxcbiAgICAgIHByb3BlcnRpZXM6IHsgLi4uZWxlbWVudFRvV3JhcC5wcm9wZXJ0aWVzIH0sXG4gICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBsZWZ0U3RyIH1dXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJpZ2h0U3RyLmxlbmd0aCA+IDAgJiYgIW5leHRFbGVtZW50Q29udGludWVzKSB7XG4gICAgbmV3SW5kZXggPSBsZWZ0U3RyLmxlbmd0aCA+IDAgPyBuZXdJbmRleCArIDIgOiBuZXdJbmRleCArIDE7XG4gICAgZWxlbWVudHMuc3BsaWNlKG5ld0luZGV4LCAwLCB7XG4gICAgICAuLi5lbGVtZW50VG9XcmFwLFxuICAgICAgcHJvcGVydGllczogeyAuLi5lbGVtZW50VG9XcmFwLnByb3BlcnRpZXMgfSxcbiAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHJpZ2h0U3RyIH1dXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFtlbGVtZW50VG9XcmFwLCBpbmRleCArIDFdO1xufVxuZnVuY3Rpb24gbmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgZWxlbWVudHMsXG4gIG5leHRJbmRleCxcbiAgcmVtYWluaW5nUGFydFxufSkge1xuICBpZiAocmVtYWluaW5nUGFydCA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBuZXh0Tm9kZSA9IGVsZW1lbnRzW25leHRJbmRleF07XG4gIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50KG5leHROb2RlKTtcbiAgaWYgKCFjb250ZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGluY2x1ZGVzTmV4dCA9IGNvbnRlbnQuc3RhcnRzV2l0aChyZW1haW5pbmdQYXJ0KSB8fCByZW1haW5pbmdQYXJ0LnN0YXJ0c1dpdGgoY29udGVudCk7XG4gIGNvbnN0IG92ZXJsYXAgPSBmaW5kT3ZlcmxhcChjb250ZW50LCByZW1haW5pbmdQYXJ0KTtcbiAgaWYgKG92ZXJsYXAgPT09IHJlbWFpbmluZ1BhcnQgJiYgY29udGVudC5zdGFydHNXaXRoKHJlbWFpbmluZ1BhcnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGluY2x1ZGVzTmV4dCkge1xuICAgIHJldHVybiBuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgZWxlbWVudHMsXG4gICAgICBuZXh0SW5kZXg6IG5leHRJbmRleCArIDEsXG4gICAgICByZW1haW5pbmdQYXJ0OiByZW1haW5pbmdQYXJ0LnJlcGxhY2UoY29udGVudCwgXCJcIilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRDb250ZW50KG5vZGUpIHtcbiAgaWYgKCFub2RlKVxuICAgIHJldHVybjtcbiAgcmV0dXJuIHRvU3RyaW5nKG5vZGUpO1xufVxuZnVuY3Rpb24gZmluZE92ZXJsYXAoYSwgYikge1xuICBpZiAoYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAoYS5lbmRzV2l0aChiKSkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIGlmIChhLmluZGV4T2YoYikgPj0gMCkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIHJldHVybiBmaW5kT3ZlcmxhcChhLCBiLnN1YnN0cmluZygwLCBiLmxlbmd0aCAtIDEpKTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VTdHJpbmcocykge1xuICByZXR1cm4gcy5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbn1cblxuLy8gc3JjL2NoYXJzL2dldEVsZW1lbnRzVG9IaWdobGlnaHQudHNcbmZ1bmN0aW9uIGdldEVsZW1lbnRzVG9IaWdobGlnaHQoZWxlbWVudCwgY2hhcnMsIHN0YXJ0SW5kZXggPSAwLCBpZ25vcmVDaGFycyA9IGZhbHNlKSB7XG4gIGNvbnN0IHRvV3JhcCA9IFtdO1xuICBsZXQgY2hhcnNTb0ZhciA9IFwiXCI7XG4gIGlmIChlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGNoYXJzU29GYXIgPyBjaGFycy5yZXBsYWNlKGNoYXJzU29GYXIsIFwiXCIpIDogY2hhcnM7XG4gICAgICBpZiAocmVtYWluaW5nID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB0b1dyYXA7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXliZUVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmICghbWF5YmVFbGVtZW50IHx8IG1heWJlRWxlbWVudC50eXBlICE9PSBcImVsZW1lbnRcIiB8fCAvLyBpZ25vcmUgYW55IHByZXZpb3VzbHkgbWF0Y2hlZCBjaGFycyB3aXRoaW5cbiAgICAgIE9iamVjdC5oYXNPd24oXG4gICAgICAgIG1heWJlRWxlbWVudC5wcm9wZXJ0aWVzID8/IHt9LFxuICAgICAgICBcInJlaHlwZS1wcmV0dHktY29kZS12aXNpdGVkXCJcbiAgICAgICkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50ID0gZ2V0Q29udGVudChtYXliZUVsZW1lbnQpIHx8IFwiXCI7XG4gICAgICBpZiAoY29udGVudCA9PT0gY2hhcnMgfHwgY2hhcnNTb0ZhciArIGNvbnRlbnQgPT09IGNoYXJzKSB7XG4gICAgICAgIHRvV3JhcC5wdXNoKHsgZWxlbWVudDogbWF5YmVFbGVtZW50LCBpbmRleDogaSB9KTtcbiAgICAgICAgcmV0dXJuIHRvV3JhcDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFycy5zdGFydHNXaXRoKGNoYXJzU29GYXIgKyBjb250ZW50KSkge1xuICAgICAgICBpZiAobmV4dEVsZW1lbnRNYXliZUNvbnRpbnVlc0NoYXJzKHtcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBuZXh0SW5kZXg6IGkgKyAxLFxuICAgICAgICAgIHJlbWFpbmluZ1BhcnQ6IHJlbWFpbmluZy5yZXBsYWNlKGNvbnRlbnQsIFwiXCIpXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgdG9XcmFwLnB1c2goeyBlbGVtZW50OiBlbGVtZW50c1tpXSwgaW5kZXg6IGkgfSk7XG4gICAgICAgICAgY2hhcnNTb0ZhciArPSBjb250ZW50O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvdmVybGFwID0gZmluZE92ZXJsYXAoY29udGVudCwgcmVtYWluaW5nKTtcbiAgICAgIGNvbnN0IHBhcnRpYWxNYXRjaCA9IG92ZXJsYXAgJiYgcmVtYWluaW5nLnN0YXJ0c1dpdGgob3ZlcmxhcCk7XG4gICAgICBpZiAocGFydGlhbE1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gcmVtYWluaW5nLnJlcGxhY2Uob3ZlcmxhcCwgXCJcIik7XG4gICAgICAgIGlmIChuZXh0UGFydCAhPT0gXCJcIiAmJiBnZXRDb250ZW50KGVsZW1lbnRzW2kgKyAxXSkgJiYgIW5leHRFbGVtZW50TWF5YmVDb250aW51ZXNDaGFycyh7XG4gICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgbmV4dEluZGV4OiBpICsgMSxcbiAgICAgICAgICByZW1haW5pbmdQYXJ0OiBuZXh0UGFydFxuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0UGFydHMgPSBjb250ZW50LnNwbGl0KG92ZXJsYXApO1xuICAgICAgICBjb25zdCBbbGVmdFBhcnQsIHJpZ2h0UGFydCwgLi4ucmVzdF0gPSBzcGxpdFBhcnRzO1xuICAgICAgICBpZiAocmlnaHRQYXJ0IHx8IGxlZnRQYXJ0IHx8IHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHdpdGhOZXh0Tm9kZSA9IGNvbnRlbnQgKyAoZ2V0Q29udGVudChlbGVtZW50c1tpICsgMV0pID8gZ2V0Q29udGVudChlbGVtZW50c1tpICsgMV0pIDogXCJcIik7XG4gICAgICAgICAgY29uc3QgbmV4dE5vZGVPdmVybGFwID0gZmluZE92ZXJsYXAod2l0aE5leHROb2RlLCByZW1haW5pbmcpO1xuICAgICAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSB3aXRoTmV4dE5vZGUuaW5kZXhPZihuZXh0Tm9kZU92ZXJsYXApO1xuICAgICAgICAgIGlmIChjaGFycy5lbmRzV2l0aChvdmVybGFwKSB8fCBjaGFycy5zdGFydHNXaXRoKG92ZXJsYXApKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodFN0cmluZyA9IHJpZ2h0UGFydC5yZXBsYWNlKG92ZXJsYXAsIFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgaW5uZXJTdHJpbmcgPSBvdmVybGFwO1xuICAgICAgICAgICAgY29uc3QgbGVmdFN0cmluZyA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHNwbGl0SW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnRDb250aW51ZXMgPSBuZXh0RWxlbWVudE1heWJlQ29udGludWVzQ2hhcnMoe1xuICAgICAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICAgICAgbmV4dEluZGV4OiBpICsgMSxcbiAgICAgICAgICAgICAgcmVtYWluaW5nUGFydDogbmV4dFBhcnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgW25ld0VsZW1lbnQsIHVwZGF0ZWRJbmRleF0gPSBzcGxpdEVsZW1lbnQoe1xuICAgICAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICAgICAgZWxlbWVudFRvV3JhcDogZWxlbWVudHNbaV0sXG4gICAgICAgICAgICAgIGlubmVyU3RyaW5nLFxuICAgICAgICAgICAgICByaWdodFN0cmluZyxcbiAgICAgICAgICAgICAgbGVmdFN0cmluZyxcbiAgICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgICAgICAgbmV4dEVsZW1lbnRDb250aW51ZXMsXG4gICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICBpZ25vcmVDaGFyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjaGFyc1NvRmFyICs9IG92ZXJsYXA7XG4gICAgICAgICAgICB0b1dyYXAucHVzaCh7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IG5ld0VsZW1lbnQsXG4gICAgICAgICAgICAgIGluZGV4OiB1cGRhdGVkSW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG9XcmFwO1xufVxuXG4vLyBzcmMvY2hhcnMvd3JhcEhpZ2hsaWdodGVkQ2hhcnMudHNcbmZ1bmN0aW9uIHdyYXBIaWdobGlnaHRlZENoYXJzKHBhcmVudEVsZW1lbnQsIGVsZW1lbnRzVG9XcmFwLCBvcHRpb25zLCBpZ25vcmVXb3JkLCBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFycykge1xuICBpZiAoIWVsZW1lbnRzVG9XcmFwIHx8IGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbeyBlbGVtZW50IH1dID0gZWxlbWVudHNUb1dyYXA7XG4gIGlmIChpZ25vcmVXb3JkKSB7XG4gICAgaWYgKGVsZW1lbnQucHJvcGVydGllcykge1xuICAgICAgZWxlbWVudC5wcm9wZXJ0aWVzW1wicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIl0gPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnRzVG9XcmFwLmxlbmd0aCA+IDEpIHtcbiAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLnNwbGljZShcbiAgICAgIGVsZW1lbnRzVG9XcmFwWzBdLmluZGV4LFxuICAgICAgZWxlbWVudHNUb1dyYXAubGVuZ3RoLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJtYXJrXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHsgXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzLW1hcmtcIjogXCJcIiB9LFxuICAgICAgICBjaGlsZHJlbjogZWxlbWVudHNUb1dyYXAubWFwKCh7IGVsZW1lbnQ6IGVsZW1lbnQzIH0pID0+IGVsZW1lbnQzKVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZWxlbWVudDIgPSBwYXJlbnRFbGVtZW50LmNoaWxkcmVuW2VsZW1lbnRzVG9XcmFwWzBdLmluZGV4XTtcbiAgICBpZiAoIWlzRWxlbWVudChlbGVtZW50MikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd29yZFN0ciA9IGVsZW1lbnQyLmNoaWxkcmVuLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IGlzRWxlbWVudChub2RlKSA/IG5vZGUuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgICAgaWYgKGlzVGV4dCh0ZXh0RWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGFjYyArIHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBcIlwiKTtcbiAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWRzTWFwLmdldCh3b3JkU3RyKTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzID0gZWxlbWVudDIucHJvcGVydGllcyB8fCB7fTtcbiAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1jaGFyc1wiXSA9IFwiXCI7XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtY2hhcnMtaWRcIl0gPSBpZDtcbiAgICBlbGVtZW50Mi50YWdOYW1lID0gXCJtYXJrXCI7XG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnM/LihlbGVtZW50MiwgaWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IFt7IGVsZW1lbnQ6IGVsZW1lbnQyIH1dID0gZWxlbWVudHNUb1dyYXA7XG4gICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50Mi5jaGlsZHJlblswXTtcbiAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBvcHRpb25zLmlkc01hcC5nZXQodGV4dEVsZW1lbnQudmFsdWUpO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXMgPSBlbGVtZW50Mi5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiXSA9IFwiXCI7XG4gICAgZWxlbWVudDIucHJvcGVydGllc1tcImRhdGEtaGlnaGxpZ2h0ZWQtY2hhcnNcIl0gPSBcIlwiO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWNoYXJzLWlkXCJdID0gaWQ7XG4gICAgZWxlbWVudDIudGFnTmFtZSA9IFwibWFya1wiO1xuICAgIGVsZW1lbnQyLmNoaWxkcmVuID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBzdHlsZTogZWxlbWVudDIucHJvcGVydGllcy5zdHlsZVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZWxlbWVudDIuY2hpbGRyZW5cbiAgICAgIH1cbiAgICBdO1xuICAgIGVsZW1lbnQyLnByb3BlcnRpZXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnM/LihlbGVtZW50MiwgaWQpO1xuICB9XG59XG5mdW5jdGlvbiBjaGFyc0hpZ2hsaWdodGVyKGVsZW1lbnQsIGNoYXJzTGlzdCwgb3B0aW9ucywgb25WaXNpdEhpZ2hsaWdodGVkQ2hhcnMpIHtcbiAgY29uc3QgeyByYW5nZXMgPSBbXSB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0b1N0cmluZyhlbGVtZW50KTtcbiAgY2hhcnNMaXN0LmZvckVhY2goKGNoYXJzLCBpbmRleCkgPT4ge1xuICAgIGlmIChjaGFycyAmJiB0ZXh0Q29udGVudD8uaW5jbHVkZXMoY2hhcnMpKSB7XG4gICAgICBsZXQgdGV4dENvbnRlbnQyID0gdG9TdHJpbmcoZWxlbWVudCk7XG4gICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICB3aGlsZSAodGV4dENvbnRlbnQyLmluY2x1ZGVzKGNoYXJzKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hhcnNSYW5nZSA9IHJhbmdlc1tpbmRleF0gfHwgW107XG4gICAgICAgIGNvbnN0IGlkID0gYCR7Y2hhcnN9LSR7aW5kZXh9YDtcbiAgICAgICAgb3B0aW9ucy5jb3VudGVyTWFwLnNldChpZCwgKG9wdGlvbnMuY291bnRlck1hcC5nZXQoaWQpIHx8IDApICsgMSk7XG4gICAgICAgIGNvbnN0IGlnbm9yZUNoYXJzID0gY3VycmVudENoYXJzUmFuZ2UubGVuZ3RoID4gMCAmJiAhY3VycmVudENoYXJzUmFuZ2UuaW5jbHVkZXMob3B0aW9ucy5jb3VudGVyTWFwLmdldChpZCkgPz8gLTEpO1xuICAgICAgICBjb25zdCBlbGVtZW50c1RvV3JhcCA9IGdldEVsZW1lbnRzVG9IaWdobGlnaHQoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBjaGFycyxcbiAgICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICAgIGlnbm9yZUNoYXJzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbGVtZW50c1RvV3JhcC5sZW5ndGggPT09IDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHdyYXBIaWdobGlnaHRlZENoYXJzKFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgZWxlbWVudHNUb1dyYXAsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpZ25vcmVDaGFycyxcbiAgICAgICAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFyc1xuICAgICAgICApO1xuICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5tYXgoXG4gICAgICAgICAgZWxlbWVudHNUb1dyYXBbZWxlbWVudHNUb1dyYXAubGVuZ3RoIC0gMV0uaW5kZXggLSAyLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgdGV4dENvbnRlbnQyID0gZWxlbWVudC5jaGlsZHJlbi5tYXAoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb3BzID0gaXNFbGVtZW50KGNoaWxkTm9kZSkgPyBjaGlsZE5vZGUucHJvcGVydGllcyA6IHt9O1xuICAgICAgICAgIGlmIChwcm9wcyAmJiAhT2JqZWN0Lmhhc093bihwcm9wcywgXCJyZWh5cGUtcHJldHR5LWNvZGUtdmlzaXRlZFwiKSAmJiAhT2JqZWN0Lmhhc093bihwcm9wcywgXCJkYXRhLWhpZ2hsaWdodGVkLWNoYXJzLW1hcmtcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZyhjaGlsZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBlbGVtZW50LmNoaWxkcmVuLmZvckVhY2goKGNoaWxkTm9kZSkgPT4ge1xuICAgIGlmICghaXNFbGVtZW50KGNoaWxkTm9kZSkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKE9iamVjdC5oYXNPd24oY2hpbGROb2RlLnByb3BlcnRpZXMsIFwicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIikpIHtcbiAgICAgIGNoaWxkTm9kZS5wcm9wZXJ0aWVzW1wicmVoeXBlLXByZXR0eS1jb2RlLXZpc2l0ZWRcIl0gPSB2b2lkIDA7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBhcHBseShlbGVtZW50LCB7XG4gIHRyZWUsXG4gIGxhbmcsXG4gIHRpdGxlLFxuICBjYXB0aW9uLFxuICBpbmxpbmUgPSBmYWxzZSxcbiAga2VlcEJhY2tncm91bmQgPSB0cnVlLFxuICBncmlkID0gdHJ1ZSxcbiAgbGluZU51bWJlcnNNYXhEaWdpdHMgPSAxLFxuICB0aGVtZSxcbiAgb25WaXNpdFRpdGxlLFxuICBvblZpc2l0Q2FwdGlvblxufSkge1xuICBlbGVtZW50LnRhZ05hbWUgPSBpbmxpbmUgPyBcInNwYW5cIiA6IFwiZmlndXJlXCI7XG4gIGVsZW1lbnQucHJvcGVydGllc1tcImRhdGEtcmVoeXBlLXByZXR0eS1jb2RlLWZpZ3VyZVwiXSA9IFwiXCI7XG4gIGNvbnN0IGNvZGVEYXRhID0gZWxlbWVudC5jaGlsZHJlblswXT8uZGF0YTtcbiAgZWxlbWVudC5jaGlsZHJlbiA9IFt0cmVlXS5tYXAoKHRyZWUyKSA9PiB7XG4gICAgY29uc3QgcHJlID0gdHJlZTIuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgdGhlbWVOYW1lcyA9IGdldFRoZW1lTmFtZXModGhlbWUpO1xuICAgIGNvbnN0IHRoZW1lTmFtZXNTdHJpbmcgPSB0aGVtZU5hbWVzLmpvaW4oXCIgXCIpO1xuICAgIGlmICghKGlzRWxlbWVudChwcmUpICYmIHByZS5wcm9wZXJ0aWVzKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gcHJlLmNoaWxkcmVuWzBdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZSkgJiYgcHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lLmluY2x1ZGVzKFwic2hpa2lcIikpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IHByZS5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5maWx0ZXIoXG4gICAgICAgIChjKSA9PiBjICE9PSBcInNoaWtpXCIgJiYgYyAhPT0gXCJzaGlraS10aGVtZXNcIiAmJiAodHlwZW9mIGMgPT09IFwic3RyaW5nXCIgPyAhdGhlbWVOYW1lcy5pbmNsdWRlcyhjKSA6IHRydWUpXG4gICAgICApO1xuICAgICAgcHJlLnByb3BlcnRpZXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lLmxlbmd0aCA+IDAgPyBjbGFzc05hbWUgOiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICgha2VlcEJhY2tncm91bmQpIHtcbiAgICAgIHByZS5wcm9wZXJ0aWVzLnN0eWxlID0gdm9pZCAwO1xuICAgIH1cbiAgICBwcmUucHJvcGVydGllc1tcImRhdGEtbGFuZ3VhZ2VcIl0gPSBsYW5nO1xuICAgIHByZS5wcm9wZXJ0aWVzW1wiZGF0YS10aGVtZVwiXSA9IHRoZW1lTmFtZXNTdHJpbmc7XG4gICAgaWYgKCEoaXNFbGVtZW50KGNvZGUpICYmIGNvZGUucHJvcGVydGllcykpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29kZS5wcm9wZXJ0aWVzW1wiZGF0YS1sYW5ndWFnZVwiXSA9IGxhbmc7XG4gICAgY29kZS5wcm9wZXJ0aWVzW1wiZGF0YS10aGVtZVwiXSA9IHRoZW1lTmFtZXNTdHJpbmc7XG4gICAgY29kZS5kYXRhID0gY29kZURhdGE7XG4gICAgaWYgKGlubGluZSkge1xuICAgICAgaWYgKGtlZXBCYWNrZ3JvdW5kKSB7XG4gICAgICAgIGNvZGUucHJvcGVydGllcy5zdHlsZSA9IHByZS5wcm9wZXJ0aWVzLnN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICAgIGlmIChncmlkKSB7XG4gICAgICBpZiAoY29kZS5wcm9wZXJ0aWVzLnN0eWxlKSB7XG4gICAgICAgIGNvZGUucHJvcGVydGllcy5zdHlsZSArPSBcImRpc3BsYXk6IGdyaWQ7XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlLnByb3BlcnRpZXMuc3R5bGUgPSBcImRpc3BsYXk6IGdyaWQ7XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3QuaGFzT3duKGNvZGUucHJvcGVydGllcywgXCJkYXRhLWxpbmUtbnVtYmVyc1wiKSkge1xuICAgICAgY29kZS5wcm9wZXJ0aWVzW1wiZGF0YS1saW5lLW51bWJlcnMtbWF4LWRpZ2l0c1wiXSA9IGxpbmVOdW1iZXJzTWF4RGlnaXRzLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudHMgPSBbXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRDb250ZW50ID0ge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogY2FwdGlvbiA/IFwiZGl2XCIgOiBcImZpZ2NhcHRpb25cIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIFwiZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtdGl0bGVcIjogXCJcIixcbiAgICAgICAgICBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZyxcbiAgICAgICAgICBcImRhdGEtdGhlbWVcIjogdGhlbWVOYW1lc1N0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiB0aXRsZSB9XVxuICAgICAgfTtcbiAgICAgIG9uVmlzaXRUaXRsZT8uKGVsZW1lbnRDb250ZW50KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGVsZW1lbnRDb250ZW50KTtcbiAgICB9XG4gICAgZnJhZ21lbnRzLnB1c2gocHJlKTtcbiAgICBpZiAoY2FwdGlvbikge1xuICAgICAgY29uc3QgZWxlbWVudENvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcImZpZ2NhcHRpb25cIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIFwiZGF0YS1yZWh5cGUtcHJldHR5LWNvZGUtY2FwdGlvblwiOiBcIlwiLFxuICAgICAgICAgIFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLFxuICAgICAgICAgIFwiZGF0YS10aGVtZVwiOiB0aGVtZU5hbWVzU3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGNhcHRpb24gfV1cbiAgICAgIH07XG4gICAgICBvblZpc2l0Q2FwdGlvbj8uKGVsZW1lbnRDb250ZW50KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGVsZW1lbnRDb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50cztcbiAgfSkuZmxhdE1hcCgoYykgPT4gYyk7XG59XG52YXIgZ2xvYmFsSGlnaGxpZ2h0ZXJDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgaGFzdFBhcnNlciA9IHVuaWZpZWQoKS51c2UocmVoeXBlUGFyc2UsIHsgZnJhZ21lbnQ6IHRydWUgfSk7XG52YXIgc3JjX2RlZmF1bHQgPSByZWh5cGVQcmV0dHlDb2RlO1xuZnVuY3Rpb24gcmVoeXBlUHJldHR5Q29kZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGdyaWQgPSB0cnVlLFxuICAgIHRoZW1lID0gXCJnaXRodWItZGFyay1kaW1tZWRcIixcbiAgICBrZWVwQmFja2dyb3VuZCA9IHRydWUsXG4gICAgZGVmYXVsdExhbmcgPSBcIlwiLFxuICAgIHRva2Vuc01hcCA9IHt9LFxuICAgIGZpbHRlck1ldGFTdHJpbmcgPSAodikgPT4gdixcbiAgICBnZXRIaWdobGlnaHRlcjogZ2V0SGlnaGxpZ2h0ZXIkMSA9IGdldEhpZ2hsaWdodGVyLFxuICAgIHRyYW5zZm9ybWVycyxcbiAgICBvblZpc2l0TGluZSxcbiAgICBvblZpc2l0SGlnaGxpZ2h0ZWRMaW5lLFxuICAgIG9uVmlzaXRIaWdobGlnaHRlZENoYXJzLFxuICAgIG9uVmlzaXRUaXRsZSxcbiAgICBvblZpc2l0Q2FwdGlvblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkodGhlbWUpO1xuICBsZXQgY2FjaGVkSGlnaGxpZ2h0ZXIgPSBnbG9iYWxIaWdobGlnaHRlckNhY2hlLmdldChrZXkpO1xuICBpZiAoIWNhY2hlZEhpZ2hsaWdodGVyKSB7XG4gICAgY2FjaGVkSGlnaGxpZ2h0ZXIgPSBnZXRIaWdobGlnaHRlciQxKHtcbiAgICAgIHRoZW1lczogaXNKU09OVGhlbWUodGhlbWUpIHx8IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IFt0aGVtZV0gOiBPYmplY3QudmFsdWVzKHRoZW1lKSxcbiAgICAgIGxhbmdzOiBbXCJwbGFpbnRleHRcIl1cbiAgICB9KTtcbiAgICBnbG9iYWxIaWdobGlnaHRlckNhY2hlLnNldChrZXksIGNhY2hlZEhpZ2hsaWdodGVyKTtcbiAgfVxuICBjb25zdCBkZWZhdWx0Q29kZUJsb2NrTGFuZyA9IHR5cGVvZiBkZWZhdWx0TGFuZyA9PT0gXCJzdHJpbmdcIiA/IGRlZmF1bHRMYW5nIDogZGVmYXVsdExhbmcuYmxvY2sgfHwgXCJcIjtcbiAgY29uc3QgZGVmYXVsdElubGluZUNvZGVMYW5nID0gdHlwZW9mIGRlZmF1bHRMYW5nID09PSBcInN0cmluZ1wiID8gZGVmYXVsdExhbmcgOiBkZWZhdWx0TGFuZy5pbmxpbmUgfHwgXCJcIjtcbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhsYW5nLCBtZXRhKSB7XG4gICAgY29uc3QgbXVsdGlwbGVUaGVtZXMgPSAhaXNKU09OVGhlbWUodGhlbWUpICYmIHR5cGVvZiB0aGVtZSA9PT0gXCJvYmplY3RcIiA/IHRoZW1lIDogbnVsbDtcbiAgICBjb25zdCBzaW5nbGVUaGVtZSA9IGlzSlNPTlRoZW1lKHRoZW1lKSB8fCB0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIgPyB0aGVtZSA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmcsXG4gICAgICBtZXRhOiB7IF9fcmF3OiBtZXRhIH0sXG4gICAgICB0cmFuc2Zvcm1lcnMsXG4gICAgICBkZWZhdWx0Q29sb3I6IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogZmFsc2UsXG4gICAgICAuLi5tdWx0aXBsZVRoZW1lcyA/IHsgdGhlbWVzOiBtdWx0aXBsZVRoZW1lcyB9IDogeyB0aGVtZTogc2luZ2xlVGhlbWUgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFzeW5jICh0cmVlKSA9PiB7XG4gICAgY29uc3QgbGFuZ3NUb0xvYWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVyID0gYXdhaXQgY2FjaGVkSGlnaGxpZ2h0ZXI7XG4gICAgaWYgKCFoaWdobGlnaHRlcilcbiAgICAgIHJldHVybjtcbiAgICB2aXNpdCh0cmVlLCBcImVsZW1lbnRcIiwgKGVsZW1lbnQsIF8sIHBhcmVudCkgPT4ge1xuICAgICAgaWYgKGlzSW5saW5lQ29kZShlbGVtZW50LCBwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gZWxlbWVudC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKCFpc1RleHQodGV4dEVsZW1lbnQpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0RWxlbWVudC52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxhbmcgPSBnZXRJbmxpbmVDb2RlTGFuZyh2YWx1ZSwgZGVmYXVsdElubGluZUNvZGVMYW5nKTtcbiAgICAgICAgaWYgKGxhbmcgJiYgbGFuZ1swXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgICBsYW5nc1RvTG9hZC5hZGQobGFuZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrQ29kZShlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjb2RlRWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNFbGVtZW50KGNvZGVFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbGFuZyB9ID0gcGFyc2VCbG9ja01ldGFTdHJpbmcoXG4gICAgICAgICAgY29kZUVsZW1lbnQsXG4gICAgICAgICAgZmlsdGVyTWV0YVN0cmluZyxcbiAgICAgICAgICBkZWZhdWx0Q29kZUJsb2NrTGFuZ1xuICAgICAgICApO1xuICAgICAgICBpZiAobGFuZykge1xuICAgICAgICAgIGxhbmdzVG9Mb2FkLmFkZChsYW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoXG4gICAgICAgIEFycmF5LmZyb20obGFuZ3NUb0xvYWQpLm1hcCgobGFuZykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZXIubG9hZExhbmd1YWdlKFxuICAgICAgICAgICAgICBsYW5nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHZpc2l0KHRyZWUsIFwiZWxlbWVudFwiLCAoZWxlbWVudCwgXywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoaXNJbmxpbmVDb2RlKGVsZW1lbnQsIHBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHRFbGVtZW50LnZhbHVlO1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qga2VlcExhbmdQYXJ0ID0gL1xcXFx7OlthLXpBLVouLV0rfSQvLnRlc3QodmFsdWUpO1xuICAgICAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0ga2VlcExhbmdQYXJ0ID8gdmFsdWUucmVwbGFjZSgvXFxcXCh7OlthLXpBLVouLV0rfSkkLywgXCIkMVwiKSA6IHZhbHVlLnJlcGxhY2UoL3s6W2EtekEtWi4tXSt9JC8sIFwiXCIpO1xuICAgICAgICB0ZXh0RWxlbWVudC52YWx1ZSA9IHN0cmlwcGVkVmFsdWU7XG4gICAgICAgIGNvbnN0IGxhbmcgPSBrZWVwTGFuZ1BhcnQgPyBcIlwiIDogZ2V0SW5saW5lQ29kZUxhbmcodmFsdWUsIGRlZmF1bHRJbmxpbmVDb2RlTGFuZyk7XG4gICAgICAgIGNvbnN0IGlzTGFuZyA9IGxhbmdbMF0gIT09IFwiLlwiO1xuICAgICAgICBpZiAoIWxhbmcpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29kZVRyZWU7XG4gICAgICAgIGlmIChpc0xhbmcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIGdldE9wdGlvbnMobGFuZykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgICBoaWdobGlnaHRlci5jb2RlVG9IdG1sKHN0cmlwcGVkVmFsdWUsIGdldE9wdGlvbnMoXCJwbGFpbnRleHRcIikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0aGVtZU5hbWVzID0gZ2V0VGhlbWVOYW1lcyh0aGVtZSk7XG4gICAgICAgICAgY29uc3QgaXNNdWx0aVRoZW1lID0gdHlwZW9mIHRoZW1lID09PSBcIm9iamVjdFwiICYmICFpc0pTT05UaGVtZSh0aGVtZSk7XG4gICAgICAgICAgY29uc3QgdGhlbWVLZXlzID0gaXNNdWx0aVRoZW1lID8gT2JqZWN0LmtleXModGhlbWUpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBjb2xvcnNCeVRoZW1lID0gdGhlbWVOYW1lcy5tYXAoXG4gICAgICAgICAgICAobmFtZSkgPT4gbmFtZSA/IGhpZ2hsaWdodGVyLmdldFRoZW1lKG5hbWUpLnNldHRpbmdzLmZpbmQoXG4gICAgICAgICAgICAgICh7IHNjb3BlIH0pID0+IHNjb3BlPy5pbmNsdWRlcyh0b2tlbnNNYXBbbGFuZy5zbGljZSgxKV0gPz8gbGFuZy5zbGljZSgxKSlcbiAgICAgICAgICAgICk/LnNldHRpbmdzLmZvcmVncm91bmQgPz8gXCJpbmhlcml0XCIgOiBcImluaGVyaXRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlzTXVsdGlUaGVtZSAmJiB0aGVtZUtleXMpIHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgYDxwcmU+PGNvZGU+PHNwYW4gc3R5bGU9XCIke3RoZW1lS2V5cy5tYXAoKGtleTIsIGkpID0+IGAtLXNoaWtpLSR7a2V5Mn06JHtjb2xvcnNCeVRoZW1lW2ldfWApLmpvaW4oXCI7XCIpfVwiPiR7c3RyaXBwZWRWYWx1ZX08L3NwYW4+PC9jb2RlPjwvcHJlPmBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgICAgYDxwcmU+PGNvZGU+PHNwYW4gc3R5bGU9XCJjb2xvcjoke2NvbG9yc0J5VGhlbWVbMF19XCI+JHtzdHJpcHBlZFZhbHVlfTwvc3Bhbj48L2NvZGU+PC9wcmU+YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXQoY29kZVRyZWUsIFwiZWxlbWVudFwiLCByZXBsYWNlTGluZUNsYXNzKTtcbiAgICAgICAgYXBwbHkoZWxlbWVudCwge1xuICAgICAgICAgIHRyZWU6IGNvZGVUcmVlLFxuICAgICAgICAgIGxhbmc6IGlzTGFuZyA/IGxhbmcgOiBcIi50b2tlblwiLFxuICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICBrZWVwQmFja2dyb3VuZCxcbiAgICAgICAgICB0aGVtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrQ29kZShlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjb2RlRWxlbWVudCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGlmICghaXNFbGVtZW50KGNvZGVFbGVtZW50KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50ID0gY29kZUVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIGNvbnN0IHsgdGl0bGUsIGNhcHRpb24sIG1ldGEsIGxhbmcgfSA9IHBhcnNlQmxvY2tNZXRhU3RyaW5nKFxuICAgICAgICAgIGNvZGVFbGVtZW50LFxuICAgICAgICAgIGZpbHRlck1ldGFTdHJpbmcsXG4gICAgICAgICAgZGVmYXVsdENvZGVCbG9ja0xhbmdcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFsYW5nIHx8IGxhbmcgPT09IFwibWF0aFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGluZU51bWJlcnMgPSBbXTtcbiAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGVzID0gbWV0YS5tYXRjaEFsbCgvXFxCXFx7KC4qPylcXH1cXEIvZyk7XG4gICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgbGluZU51bWJlcnMucHVzaCguLi5yYW5nZVBhcnNlcjIobWF0Y2hbMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVOdW1iZXJzTWF4RGlnaXRzID0gMDtcbiAgICAgICAgY29uc3QgbGluZUlkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY2hhcnNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGNoYXJzTGlzdE51bWJlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgY2hhcnNMaXN0SWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjaGFyc01hdGNoZXMgPSBtZXRhID8gW1xuICAgICAgICAgIC4uLm1ldGEubWF0Y2hBbGwoXG4gICAgICAgICAgICAvKD88ZGVsaW1pdGVyPltcIi9dKSg/PGNoYXJzPi4qPylcXGs8ZGVsaW1pdGVyPig/PGNoYXJzSWRBbmRPclJhbmdlPlxcUyopL2dcbiAgICAgICAgICApXG4gICAgICAgIF0gOiB2b2lkIDA7XG4gICAgICAgIGxpbmVOdW1iZXJzLmZvckVhY2goKGxpbmVOdW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGdldExpbmVJZChsaW5lTnVtYmVyLCBtZXRhKTtcbiAgICAgICAgICBpZCAmJiBsaW5lSWRNYXAuc2V0KGxpbmVOdW1iZXIsIGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoYXJzTWF0Y2hlcykpIHtcbiAgICAgICAgICBjaGFyc01hdGNoZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFycywgY2hhcnNJZEFuZE9yUmFuZ2UgfSA9IG5hbWUuZ3JvdXBzO1xuICAgICAgICAgICAgY2hhcnNMaXN0LnB1c2goY2hhcnMpO1xuICAgICAgICAgICAgaWYgKGNoYXJzSWRBbmRPclJhbmdlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGNoYXJzTGlzdE51bWJlcnMucHVzaChbXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBbcmFuZ2UsIGlkXSA9IGNoYXJzSWRBbmRPclJhbmdlLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgICAgICAgcmFuZ2UgJiYgY2hhcnNMaXN0TnVtYmVycy5wdXNoKHJhbmdlUGFyc2VyMihyYW5nZSkpO1xuICAgICAgICAgICAgICBpZCAmJiBjaGFyc0xpc3RJZE1hcC5zZXQoY2hhcnMsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVGV4dCh0ZXh0RWxlbWVudCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gdGV4dEVsZW1lbnQudmFsdWUucmVwbGFjZSgvXFxuJC8sIFwiXCIpO1xuICAgICAgICBsZXQgY29kZVRyZWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29kZVRyZWUgPSBoYXN0UGFyc2VyLnBhcnNlKFxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXIuY29kZVRvSHRtbChzdHJpcHBlZFZhbHVlLCBnZXRPcHRpb25zKGxhbmcsIG1ldGEpKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGNvZGVUcmVlID0gaGFzdFBhcnNlci5wYXJzZShcbiAgICAgICAgICAgIGhpZ2hsaWdodGVyLmNvZGVUb0h0bWwoXG4gICAgICAgICAgICAgIHN0cmlwcGVkVmFsdWUsXG4gICAgICAgICAgICAgIGdldE9wdGlvbnMoXCJwbGFpbnRleHRcIiwgbWV0YSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lQ291bnRlciA9IDA7XG4gICAgICAgIGNvbnN0IGNoYXJzSGlnaGxpZ2h0ZXJPcHRpb25zID0ge1xuICAgICAgICAgIHJhbmdlczogY2hhcnNMaXN0TnVtYmVycyxcbiAgICAgICAgICBpZHNNYXA6IGNoYXJzTGlzdElkTWFwLFxuICAgICAgICAgIGNvdW50ZXJNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgdmlzaXQoY29kZVRyZWUsIFwiZWxlbWVudFwiLCAoZWxlbWVudDIpID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudDIudGFnTmFtZSA9PT0gXCJjb2RlXCIgJiYgL3NyZWJtdU5lbmlMd29ocyg/ISguKikoXFwvKSkvLnRlc3QocmV2ZXJzZVN0cmluZyhtZXRhKSkpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Mi5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQyLnByb3BlcnRpZXNbXCJkYXRhLWxpbmUtbnVtYmVyc1wiXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyc1N0YXJ0QXRNYXRjaCA9IHJldmVyc2VTdHJpbmcobWV0YSkubWF0Y2goXG4gICAgICAgICAgICAgIC8oPzpcXH0oXFxkKyl7KT9zcmVibXVOZW5pTHdvaHMoPyEoLiopKFxcLykpL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TnVtYmVyU3RyaW5nID0gbGluZU51bWJlcnNTdGFydEF0TWF0Y2g/LlsxXTtcbiAgICAgICAgICAgIGlmIChzdGFydE51bWJlclN0cmluZykge1xuICAgICAgICAgICAgICBjb25zdCBzdGFydEF0ID0gc3RhcnROdW1iZXJTdHJpbmcgPyBOdW1iZXIocmV2ZXJzZVN0cmluZyhzdGFydE51bWJlclN0cmluZykpIC0gMSA6IDA7XG4gICAgICAgICAgICAgIGxpbmVOdW1iZXJzTWF4RGlnaXRzID0gc3RhcnRBdDtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzLnN0eWxlID0gYGNvdW50ZXItc2V0OiBsaW5lICR7c3RhcnRBdH07YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50Mi5wcm9wZXJ0aWVzPy5jbGFzc05hbWUpICYmIGVsZW1lbnQyLnByb3BlcnRpZXM/LmNsYXNzTmFtZT8uWzBdID09PSBcImxpbmVcIikge1xuICAgICAgICAgICAgaWYgKGdyaWQgJiYgdG9TdHJpbmcoZWxlbWVudDIpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQyLmNoaWxkcmVuID0gW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIiBcIiB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VMaW5lQ2xhc3MoZWxlbWVudDIpO1xuICAgICAgICAgICAgb25WaXNpdExpbmU/LihlbGVtZW50Mik7XG4gICAgICAgICAgICBsaW5lQ291bnRlcisrO1xuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJzLmluY2x1ZGVzKGxpbmVDb3VudGVyKSkge1xuICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1saW5lXCJdID0gXCJcIjtcbiAgICAgICAgICAgICAgY29uc3QgbGluZUlkID0gbGluZUlkTWFwLmdldChsaW5lQ291bnRlcik7XG4gICAgICAgICAgICAgIGlmIChsaW5lSWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Mi5wcm9wZXJ0aWVzW1wiZGF0YS1oaWdobGlnaHRlZC1saW5lLWlkXCJdID0gbGluZUlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9uVmlzaXRIaWdobGlnaHRlZExpbmU/LihlbGVtZW50MiwgbGluZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJzSGlnaGxpZ2h0ZXIoXG4gICAgICAgICAgICAgIGVsZW1lbnQyLFxuICAgICAgICAgICAgICBjaGFyc0xpc3QsXG4gICAgICAgICAgICAgIGNoYXJzSGlnaGxpZ2h0ZXJPcHRpb25zLFxuICAgICAgICAgICAgICBvblZpc2l0SGlnaGxpZ2h0ZWRDaGFyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzTWF4RGlnaXRzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXBwbHkoZWxlbWVudCwge1xuICAgICAgICAgIHRyZWU6IGNvZGVUcmVlLFxuICAgICAgICAgIGxhbmcsXG4gICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgY2FwdGlvbixcbiAgICAgICAgICBrZWVwQmFja2dyb3VuZCxcbiAgICAgICAgICBncmlkLFxuICAgICAgICAgIGxpbmVOdW1iZXJzTWF4RGlnaXRzLFxuICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgIG9uVmlzaXRUaXRsZSxcbiAgICAgICAgICBvblZpc2l0Q2FwdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgc3JjX2RlZmF1bHQgYXMgZGVmYXVsdCwgcmVoeXBlUHJldHR5Q29kZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rehype-pretty-code/dist/index.js\n");

/***/ })

};
;